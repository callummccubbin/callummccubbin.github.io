<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="three.js"></script>
        <script type="x-shader/x-vertex" id="vertexShader">

            varying vec3 vWorldPosition;

            void main() {

                vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                vWorldPosition = worldPosition.xyz;

                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

            }

        </script>
        <script type="x-shader/x-fragment" id="fragmentShader">

			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;

			varying vec3 vWorldPosition;

			void main() {

				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );

			}

		</script>
		<script>

            //             //id = int, position = Vector3, box = BoxGeometry
            // class cuboid {
            //     constructor(id, position, box) {
            //         this.id = id;
            //         this.position = position;
            //         this.box = box;
            //     }
            // }
            
            window.addEventListener("keydown", function (event) {
            if (event.defaultPrevented) {
                return; // Do nothing if the event was already processed
            }

            switch (event.key) {
                case "ArrowDown":
                    cubes[0].attemptMove(zhat());
                break;
                case "ArrowUp":
                    //console.log("up");
                    cubes[0].attemptMove(zhat().negate());
                break;
                case "ArrowLeft":
                    cubes[0].attemptMove(xhat().negate());
                break;
                case "ArrowRight":
                    cubes[0].attemptMove(xhat());
                break;
                case " ":
                    cubes[0].attemptClimb();
                default:
                return; // Quit when this doesn't handle the key event.
            }

            // Cancel the default action to avoid it being handled twice
            event.preventDefault();
            }, true);

            const scene = new THREE.Scene();

            const camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 5000 );

            scene.background = new THREE.Color().setHSL( 0.6, 0, 1 );
            scene.fog = new THREE.Fog( scene.background, 1, 5000 );

            const renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.shadowMap.enabled = true;
            document.body.appendChild( renderer.domElement );


            //LIGHTS

            const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
            hemiLight.color.setHSL( 0.6, 1, 0.6 );
            hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
            hemiLight.position.set( 0, 10, 0 );
            scene.add( hemiLight );

            //const hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 10 );
            //scene.add( hemiLightHelper );

            //

            const dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
            dirLight.color.setHSL( 0.1, 1, 0.95 );
            dirLight.position.set( - 1, 1.75, 1 );
            dirLight.position.multiplyScalar( 30 );
            scene.add( dirLight );

            //const cameraHelper = new THREE.CameraHelper(dirLight.shadow.camera);
            //  scene.add(cameraHelper);

            dirLight.castShadow = true;

            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;

            const d = 50;

            dirLight.shadow.camera.left = - d;
            dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d;
            dirLight.shadow.camera.bottom = - d;

            dirLight.shadow.camera.far = 3500;
            dirLight.shadow.bias = - 0.000001;

            //const dirLightHelper = new THREE.DirectionalLightHelper( dirLight, 10 );
            //scene.add( dirLightHelper );

            // // GROUND

            const groundGeo = new THREE.PlaneGeometry( 10000, 10000 );
            const groundMat = new THREE.MeshLambertMaterial( { color: 0xffffff } );
            groundMat.color.setHSL( 0.095, 1, 0.75 );

            const ground = new THREE.Mesh( groundGeo, groundMat );
            ground.position.y = -0.5;
            ground.rotation.x = - Math.PI / 2;
            ground.receiveShadow = true;
            scene.add( ground );

            // // SKYDOME

            const vertexShader = document.getElementById( 'vertexShader' ).textContent;
            const fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
            const uniforms = {
                'topColor': { value: new THREE.Color( 0x0077ff ) },
                'bottomColor': { value: new THREE.Color( 0xffffff ) },
                'offset': { value: 33 },
                'exponent': { value: 0.6 }
            };
            uniforms[ 'topColor' ].value.copy( hemiLight.color );

            scene.fog.color.copy( uniforms[ 'bottomColor' ].value );

            const skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
            const skyMat = new THREE.ShaderMaterial( {
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                side: THREE.BackSide
            } );

            const sky = new THREE.Mesh( skyGeo, skyMat );
            scene.add( sky );

            // GRID

            const maxGridCoordinate = 5
            const gridSize = maxGridCoordinate * 2 + 1;

            let grid = new Map();

            function encodePos(pos) {
                let gridKey = pos.x + (pos.y * gridSize) + (pos.z * (gridSize ** 2));
                return gridKey;
            }

            function decodeGridKey(gridKey) {
                let x = gridKey % gridSize;
                let y = ((gridKey - x) % (gridSize ** 2)) / gridSize;
                let z = (gridKey - x - (y * gridSize)) / (gridSize ** 2);
                return new THREE.Vector3(x, y, z);
            }

            // -1 means there's empty space
            // -2 means there's a dead cube
            // 0 and greater is a living cube of that id number

            let gridHelper = new THREE.GridHelper(gridSize, gridSize);
            scene.add(gridHelper);
            gridHelper.position.x = maxGridCoordinate;
            gridHelper.position.z = maxGridCoordinate;
            gridHelper.position.y = -0.4;

            //

            function xhat() {
                vec = new THREE.Vector3(1, 0, 0);
                return vec;
            }
            function yhat() {
                vec = new THREE.Vector3(0, 1, 0);
                return vec;
            }
            function zhat() {
                vec = new THREE.Vector3(0, 0, 1);
                return vec;
            }
            function zero() {
                vec = new THREE.Vector3(0, 0, 0);
                return vec;
            }

            function lerp(x, y, t) {
                return x + t * (y - x);
            }

            // -----------------------------------------

            class cube {
                constructor(id, gridPosition, mesh) {
                    this.id = id;
                    this.gridPosition = new THREE.Vector3(0, 0, 0);
                    this.gridPosition.copy(gridPosition);
                    this.mesh = mesh;
                    this.mesh.receiveShadow = true;
                    this.mesh.castShadow = true;
                    this.mesh.position.copy(this.gridPosition);

                    grid.set(encodePos(this.gridPosition), this.id);
                }

                attemptClimb() {
                    if(this.check(xhat()) >= 0 ||
                    this.check(xhat().negate()) >= 0 ||
                    this.check(zhat()) >= 0 ||
                    this.check(zhat().negate()) >= 0) {
                        if (this.check(yhat() == -1)) {
                            this.attemptMove(yhat());
                        }
                    }
                }

                checkFall() {
                    let safe = this.check(new THREE.Vector3(0,-1,-1)) > -1 ||
                                this.check(new THREE.Vector3(0,-1,0)) > -1 ||
                                this.check(new THREE.Vector3(0,-1,1)) > -1 ||
                                this.check(new THREE.Vector3(1,-1,-1)) > -1 ||
                                this.check(new THREE.Vector3(1,-1,0)) > -1 ||
                                this.check(new THREE.Vector3(1,-1,1)) > -1 ||
                                this.check(new THREE.Vector3(-1,-1,-1)) > -1 ||
                                this.check(new THREE.Vector3(-1,-1,0)) > -1 ||
                                this.check(new THREE.Vector3(-1,-1,1)) > -1;

                    if (this.gridPosition.y == 0) {
                        safe = true;
                    }
                    if (!safe) {
                        // descend unto the earth
                        this.move(yhat().negate());
                    }
                }

                check(direction) {
                    let newPos = new THREE.Vector3(0, 0, 0);
                    newPos.copy(this.gridPosition);
                    newPos.x += direction.x;
                    newPos.y += direction.y;
                    newPos.z += direction.z;

                    if (Math.abs(newPos.x) < gridSize &&
                    Math.abs(newPos.x) < gridSize &&
                    Math.abs(newPos.z) < gridSize &&
                    newPos.x >= 0 &&
                    newPos.y >= 0 &&
                    newPos.z >= 0) {  

                        if (!grid.has(encodePos(newPos))) {
                            return -1;
                        } else {
                            return grid.get(encodePos(newPos));
                        }
                    } else {
                        return -2;
                    }
                }

                move(direction) {
                    let newPos = new THREE.Vector3(0, 0, 0);
                
                    newPos.copy(this.gridPosition);

                    newPos.x += direction.x;
                    newPos.y += direction.y;
                    newPos.z += direction.z;
                    
                    console.log(newPos.x + " newPos.x");
                    console.log(this.gridPosition.x + " gridPosition.x");

                    grid.delete(encodePos(this.gridPosition));
                    grid.set(encodePos(newPos), this.id);
                    this.gridPosition = newPos;
                    this.checkFall();
                }

                attemptMove(direction) {
                    let c = this.check(direction);
                    console.log(c);
                    if (c == -1) {
                        this.move(direction);
                    }
                }

            }

            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshStandardMaterial( { color: 0xa7c330 } );

            let cubes = [];

            for (i = 0; i < 9; i++) {

                // console.log(grid[5][5][5], "555");
                // console.log(grid[6][5][5], "655");
                // console.log(grid[5][6][5], "565");
                // console.log(grid[5][5][6], "556");

                cubes[i] = new cube(i, new THREE.Vector3(i, i-1, i), new THREE.Mesh(geometry, material));
                cubes[0].gridPosition.y += 1;
                scene.add(cubes[i].mesh);

                // console.log(grid[5][5][5], "555");
                // console.log(grid[6][5][5], "655");
                // console.log(grid[5][6][5], "565");
                // console.log(grid[5][5][6], "556");


                // console.log(grid[cubes[i].gridPosition.x]
                // [cubes[i].gridPosition.y]
                // [cubes[i].gridPosition.z]);
            }

            camera.position.set( 0, 20, 40);
            camera.rotation.x = -.4;
            let rCamera = 40;
            let thetaCamera = 0;
            let rLight = 40
            let thetaLight = 0
			function animate() {
				requestAnimationFrame( animate );
                //camera.rotateOnWorldAxis(yhat(), 0.01);
                //thetaCamera += 0.01;
                thetaLight -= 0.005;
                camera.position.x = rCamera * Math.sin(thetaCamera);
                camera.position.z = rCamera * Math.cos(thetaCamera);

                dirLight.position.x = rLight * Math.sin(thetaLight);
                dirLight.position.z = rLight * Math.cos(thetaLight);

                //console.log(cubes[0].gridPosition.x);
                cubes[0].mesh.position.lerp(cubes[0].gridPosition, 0.3);

				renderer.render( scene, camera );
			};
			animate();
		</script>
	</body>
</html>